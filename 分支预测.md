# 分支预测

### 总览

分支预测包括两个要素

1、方向， 是否跳转。部分riscv指令如JAL JALR是无条件跳转的，而BEQ等指令需要要求满足才能跳转。

2、目标地址，跳转的目标地址通常位于指令当中。又分为两种情况：直接跳转， pc + offset, offset范围通常不大，较为容易进行预测，推荐；间接跳转，目标地址来自通用寄存器的值，可跳到处理器空间的任意位置，并且该通用寄存器的值可能来自其他指令的结果，需要等之前的指令进行到流水线的执行阶段才能得到，加大了预测失败的惩罚，但是程序中间接跳转通常是来自call/return指令，可以寻找规律。

普通流水线如果深度不深总是预测不执行，在执行阶段得到方向和目标地址之后才进行判断。如果跳转，需要抛弃在该分支指令之后进入流水线的所有指令，不发生跳转则没有影响。举例Mips r3000, 在译码阶段得到分支指令的两个结果，如果预测失败，只需要抛弃取指阶段的一条指令                                                                    

<img src="分支预测.assets/image-20210905204527733.png" alt="image-20210905204527733" style="zoom:50%;" />

对于复杂处理器，使用动态分支预测，下文的分支预测都是指代动态分支预测。

首先需要知道从icache中取出的哪些指令是分支预测指令，对于多发射的超标量处理器来说，需从指令组中找出分支指令。

<img src="分支预测.assets/image-20210905204856613.png" alt="image-20210905204856613" style="zoom:50%;" />

容易想到的方式是从icache中取出指令后，就进行快速译码，然后将分支指令对应的pc送到分支预测器，当处理器的周期时间较小时，icache的访问可能需要多个

<img src="分支预测.assets/image-20210905205048826.png" alt="image-20210905205048826" style="zoom:50%;" />

周期才能完成，采用上图的方式，从取指令到分支预测得到结果，间隔了好几个周期，这些周期内只能顺序取指令，也就是预测不发生跳转，降低了预测准确度。并且图中译码和分支预测都放在同一个阶段，严重影响处理器周期时间。一个解决方式是，在L2cache写到icache之前进行预解码，然后将是否是分支指令的信息和指令一起写到icache中。但是从取值到分支预测得到结果的时间仍然很长。

需要明白，在流水线中分支预测越靠前越好，这样预测失败的惩罚会大大降低，所以选择取指令时分支预测，这样下一个周期就能根据预测的结果继续取指令。

### 指令类型预测

对一条指令而言，物理地址是会变化的（取决于操作系统将它放在物理内存中的位置），但是虚拟地址PC值是不会变化的，同一个进程中每一个PC对应固定的指令，从而可以使用pc进行分支预测，但是在进程切换时，需要将分支预测器中的内存进行清空，如果加入ASID(上下文切换id),就可以将他和pc一起预测，不用清空。

在pc值刚产生的周期，根据该pc值来预测本周期的指令组中是否存在分支指令，以及预测的方向和地址。

<img src="分支预测.assets/image-20210905211859471.png" alt="image-20210905211859471" style="zoom:50%;" />

当程序开始执行，每条指令对应的pc也固定了，因此可以根据pc来预测是否是分支指令。当这条分支指令第一次被执行完后，后面再次遇到这个pc就能知道当前的指令是跳转指令，这里仅能识别是否是分支指令，对于方向和目标地址，看下文。

### 分支指令方向预测

对于循环`for(i=0;i<1000;i++)`,for语句会被编译成一条分支指令，该分支指令会向同一个方向执行1000次，因此他的方向是有规律的。

比较简单的预测方法是直接使用上次的结果，也成为last-outcome prediction。

<img src="分支预测.assets/image-20210905213330883.png" alt="image-20210905213330883" style="zoom:50%;" />

图4.6算法正确率可以达到0.002%,但是图4.7算法正确率为0，因此该预测方法并没有用于现代处理器。现代处理器都是基于两位饱和预测器(2-bit saturating counter)。

基于两位饱和预测器根据一条分支指令的前两次执行结果预测本次方向，使用如下状态机

<img src="分支预测.assets/image-20210905213722600.png" alt="image-20210905213722600" style="zoom:50%;" />

Strongly not taken : 编码00  饱和     预测不跳转

Weakly not taken   : 编码01  不饱和  预测不跳转

Weakly taken          : 编码10  不饱和  预测跳转

Strongly taken        : 编码11  饱和      预测跳转

处于饱和态时，两次预测失败才会改变预测结果，当分支指令总是朝着一个方向时，就处于饱和状态，方向总是变化时，就无法处于饱和状态。上图是其中一种状态机实现，下面再给出两种<img src="分支预测.assets/image-20210905214442143.png" alt="image-20210905214442143" style="zoom:50%;" />

对于一般的基准测试，状态机的变化不会取得更优结果，但是对于初始状态，需要根据实际情况决定，通常使用strongly not taken 或者 weakly not taken决定。可以使用格雷码对状态机进行编码，这样状态切换时只有一位会发生变化，减少出错并降低功耗。在两个饱和状态，计数器达到最大或者最小值，此时分支指令的方向如果继续保持不变，，就会使状态停留在原地不再发生变化，相当于“饱和”。

举例说明，`for(i=0;i<m;i++)` 假设第一次循环时处于weakly not taken, 

